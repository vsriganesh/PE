package com.iiitb.utility;

import static org.junit.Assert.*;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

import com.iiitb.blocks.Block;
import com.iiitb.blocks.Delay;
import com.iiitb.cfg.Accfg;
import com.iiitb.constant.Constants;
import com.iiitb.sort.TopologicalSort;

import expression.Expression;
import expression.Variable;

public class MergeAccfgTest {

	@BeforeClass
	public static void setUpBeforeClass() throws Exception {
	}

	@AfterClass
	public static void tearDownAfterClass() throws Exception {
	}

	@Before
	public void setUp() throws Exception {
	}

	@After
	public void tearDown() throws Exception {
	}

	public static Accfg merge(ArrayList<Block> blockList) {

		Accfg merged = null;
		List<Expression> fpList = new ArrayList<Expression>();
		List<Expression> initList = new ArrayList<Expression>();
		List<Expression> delayList = new ArrayList<Expression>();
		/* Created a new list and copied all values from blockList. This is required since we remove blockList entries during iteration.
		 * We pass "blockListToPass" to  findInputOutputVariable method
		 */
		List<Block> blockListToPass = new ArrayList<Block>();
		blockListToPass.addAll(blockList);
		
		merged = new Accfg();
		
		
			//Topological sort 
		  
		
		  TopologicalSort ts = new TopologicalSort();
		 Iterator<String> iterKey =  FetchInputFromLine.adjacencyList.keySet().iterator();
		
		 Map<String,LinkedList<String>> tempMap = new HashMap<String,LinkedList<String>>();
		 while(iterKey.hasNext())
		 {
			 String key = iterKey.next();
			 Iterator<DestNode> tempIter = FetchInputFromLine.adjacencyList.get(key).iterator();
			 LinkedList<String> tempList = new LinkedList<String>();
			 while(tempIter.hasNext())
			 {
				 tempList.add(tempIter.next().getName());
			 }
			 
			 tempMap.put(key, tempList);
		 }
		  ArrayList<String> sortedList = ts.sortGraph(tempMap);
		
		  System.out.println("Before Sort List "+blockList);
		  System.out.println("Sorted List "+sortedList);
		
		
	

		Iterator sortedIter = sortedList.iterator();
		
		String sortFp = "";

		while (sortedIter.hasNext()) {
			sortFp = (String) sortedIter.next();
			
			Iterator iter = blockList.iterator();
			while (iter.hasNext()) {
				Block block = (Block) iter.next();
				
				
				if (((Variable)block.getOutput()).getName().equalsIgnoreCase(sortFp)) {
					
					fpList.addAll(block.getAccfg().getFp());
					initList.addAll(block.getAccfg().getInit());
					/*For Delay block with delay_length >1 , first individual delay components
					 * are added to delayList*/
					if(sortFp.startsWith(Constants.DELAY))
					{
						delayList.addAll(block.getAccfg().getDelay());
						Iterator<Delay> delayIter = ((Delay)block).getDelayLengthList().iterator();
						while(delayIter.hasNext())
						{
							delayList.addAll(delayIter.next().getAccfg().getDelay());
						
						}
						
					}
					
					iter.remove();
					break;
				}

			}

		}

		merged.setFp(fpList);
		merged.setInit(initList);
		merged.setDelay(delayList);

		// Call to set input and output
		merged = findInputOutputVariable(merged, (ArrayList<Block>)blockListToPass);

		// System.out.println(merged);
		return merged;

	}

}
